/*
 * ESP32 Customer Configuration
 * Organization: {{ORGANIZATION}}
 * Customer ID: {{CUSTOMER_ID}}
 * Application: {{APPLICATION_NAME}}
 * Generated: {{GENERATED_DATE}}
 */

#include <WiFi.h>
#include <ESPAsyncWebServer.h>
#include <ArduinoJson.h>
#include <Wire.h>
#include <Adafruit_SHT31.h>

// Customer Configuration
const char* CUSTOMER_ORG = "{{ORGANIZATION}}";
const char* CUSTOMER_ID = "{{CUSTOMER_ID}}";  
const char* APPLICATION_NAME = "{{APPLICATION_NAME}}";

// SHT30 I2C Sensor Configuration (Using default I2C pins)
Adafruit_SHT31 sht31 = Adafruit_SHT31();

// Sensor status tracking
bool sensorAvailable = false;
String sensorErrorMessage = "";
String sensorMode = "unknown";

// WiFi Access Point Configuration
const char* AP_SSID = "{{WIFI_SSID}}";
const char* AP_PASSWORD = "{{WIFI_PASSWORD}}";
IPAddress local_ip(192, 168, 4, 1);
IPAddress gateway(192, 168, 4, 1);
IPAddress subnet(255, 255, 255, 0);

// Create AsyncWebServer object on port 80
AsyncWebServer server(80);

void setup() {
  Serial.begin(115200);
  Serial.println();
  Serial.println("========================================");
  Serial.println("SMC ESP32 Customer Configuration");
  Serial.printf("Customer: %s (%s)\n", CUSTOMER_ORG, CUSTOMER_ID);
  Serial.printf("Application: %s\n", APPLICATION_NAME);
  Serial.println("========================================");
  
  // Initialize Wi-Fi
  Serial.println("Starting WiFi Access Point...");
  WiFi.mode(WIFI_AP);
  WiFi.softAPConfig(local_ip, gateway, subnet);
  WiFi.softAP(AP_SSID, AP_PASSWORD);
  
  Serial.printf("AP SSID: %s\n", AP_SSID);
  Serial.printf("AP IP Address: %s\n", WiFi.softAPIP().toString().c_str());
  Serial.printf("MAC Address: %s\n", WiFi.macAddress().c_str());
  
  // Initialize I2C for SHT30 Sensor - Medical Device Compliance
  Serial.println("MEDICAL: Initializing SHT30 I2C Temperature/Humidity Sensor...");
  Wire.begin(); // Use default I2C pins (SDA=21, SCL=22 for ESP32)
  Wire.setClock(100000); // Set I2C clock to 100kHz for stable communication
  Serial.println("HARDWARE: I2C initialized with default pins, Clock=100kHz");
  
  // Medical Device Sensor Validation with Retry Logic
  Serial.println("MEDICAL: Testing sensor connectivity with retry mechanism...");
  delay(1000); // Wait for I2C to stabilize
  
  bool sensorInitialized = false;
  int retryCount = 0;
  const int maxRetries = 3;
  
  // Retry loop for medical device reliability
  while (!sensorInitialized && retryCount < maxRetries) {
    retryCount++;
    Serial.printf("MEDICAL: Sensor initialization attempt %d/%d\n", retryCount, maxRetries);
    
    if (sht31.begin(0x44)) {
      delay(500); // Allow sensor to stabilize after initialization
      
      // Perform comprehensive sensor validation
      float temp = sht31.readTemperature();
      float humidity = sht31.readHumidity();
      
      // Medical device range validation (extended for safety)
      if (!isnan(temp) && !isnan(humidity) && 
          temp >= -40.0 && temp <= 85.0 &&     // SHT30 operating range
          humidity >= 0.0 && humidity <= 100.0) {
        
        sensorInitialized = true;
        sensorAvailable = true;
        sensorMode = "live";
        Serial.println("MEDICAL: ✅ SHT30 sensor validated and operational");
        Serial.printf("MEDICAL: Initial reading validated - Temp: %.2f°C, Humidity: %.2f%%RH\n", temp, humidity);
        Serial.printf("MEDICAL: Sensor status - Address: 0x44, Mode: Live, Retry: %d\n", retryCount);
      } else {
        sensorErrorMessage = "Sensor reading validation failed - Invalid temperature or humidity values";
        Serial.printf("ERROR: %s - Temp: %.2f, Humidity: %.2f\n", sensorErrorMessage.c_str(), temp, humidity);
        delay(1000); // Wait before retry
      }
    } else {
      sensorErrorMessage = "I2C communication failed - SHT30 sensor not responding at address 0x44";
      Serial.printf("ERROR: %s on attempt %d\n", sensorErrorMessage.c_str(), retryCount);
      delay(1000); // Wait before retry
    }
  }
  
  // Final sensor status determination - NO MOCK DATA
  if (!sensorInitialized) {
    sensorAvailable = false;
    sensorMode = "error";
    if (sensorErrorMessage.isEmpty()) {
      sensorErrorMessage = "SHT30 sensor initialization failed after " + String(maxRetries) + " retry attempts";
    }
    Serial.printf("ERROR: %s\n", sensorErrorMessage.c_str());
    Serial.println("MEDICAL: ⚠️  Hardware validation required - System will return sensor errors");
  }

  // Configure CORS
  DefaultHeaders::Instance().addHeader("Access-Control-Allow-Origin", "*");
  DefaultHeaders::Instance().addHeader("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS");
  DefaultHeaders::Instance().addHeader("Access-Control-Allow-Headers", "*");

  // Root endpoint
  server.on("/", HTTP_GET, [](AsyncWebServerRequest *request) {
    String html = "<!DOCTYPE html><html><head><title>SMC ESP32 - " + String(CUSTOMER_ORG) + "</title></head>";
    html += "<body style='font-family: Arial; padding: 20px;'>";
    html += "<h1>SMC Medical Device Configuration</h1>";
    html += "<div style='background: #f0f0f0; padding: 15px; border-radius: 5px;'>";
    html += "<h3>Customer Information</h3>";
    html += "<p><strong>Organization:</strong> " + String(CUSTOMER_ORG) + "</p>";
    html += "<p><strong>Customer ID:</strong> " + String(CUSTOMER_ID) + "</p>";
    html += "<p><strong>Application:</strong> " + String(APPLICATION_NAME) + "</p>";
    html += "<p><strong>MAC Address:</strong> " + WiFi.macAddress() + "</p>";
    html += "</div></body></html>";
    
    request->send(200, "text/html", html);
  });

  // MAC endpoint
  server.on("/mac", HTTP_GET, [](AsyncWebServerRequest *request) {
    JsonDocument doc;
    doc["mac_address"] = WiFi.macAddress();
    doc["customer_id"] = CUSTOMER_ID;
    doc["organization"] = CUSTOMER_ORG;
    doc["status"] = "success";
    doc["timestamp"] = millis();
    
    String jsonString;
    serializeJson(doc, jsonString);
    request->send(200, "application/json", jsonString);
  });

  // Info endpoint  
  server.on("/info", HTTP_GET, [](AsyncWebServerRequest *request) {
    JsonDocument doc;
    JsonObject deviceObj = doc["device"].to<JsonObject>();
    deviceObj["type"] = "ESP32";
    deviceObj["mac_address"] = WiFi.macAddress();
    deviceObj["ap_ip"] = WiFi.softAPIP().toString();
    deviceObj["ap_ssid"] = AP_SSID;
    
    JsonObject customerObj = doc["customer"].to<JsonObject>();
    customerObj["organization"] = CUSTOMER_ORG;
    customerObj["customer_id"] = CUSTOMER_ID;
    customerObj["application"] = APPLICATION_NAME;
    
    String jsonString;
    serializeJson(doc, jsonString);
    request->send(200, "application/json", jsonString);
  });

  // Sensor endpoint - SHT30 I2C Temperature/Humidity 
  server.on("/sensor", HTTP_GET, [](AsyncWebServerRequest *request) {
    JsonDocument doc;
    
    if (!sensorAvailable) {
      // Sensor not available - return error response
      doc["success"] = false;
      doc["error"] = "SHT30 sensor not available";
      doc["error_details"] = sensorErrorMessage;
      doc["sensor"] = "SHT30";
      doc["mode"] = sensorMode;
      doc["sensor_available"] = false;
      doc["timestamp"] = millis();
      doc["customer_id"] = CUSTOMER_ID;
      doc["troubleshooting"] = "Check I2C connections, verify sensor power supply, ensure correct I2C address (0x44)";
      
      String jsonString;
      serializeJson(doc, jsonString);
      Serial.printf("ERROR: Sensor endpoint returning error - %s\n", sensorErrorMessage.c_str());
      request->send(500, "application/json", jsonString);
      return;
    }
    
    // Try to read from real sensor
    float temperature = sht31.readTemperature();
    float humidity = sht31.readHumidity();
    
    // Validate sensor readings
    if (isnan(temperature) || isnan(humidity) || 
        temperature <= -40 || temperature >= 80 || 
        humidity < 0 || humidity > 100) {
      
      // Sensor reading failed - return error
      doc["success"] = false;
      doc["error"] = "SHT30 sensor reading failed";
      doc["error_details"] = "Invalid sensor readings - temperature: " + String(temperature) + "°C, humidity: " + String(humidity) + "%";
      doc["sensor"] = "SHT30";
      doc["mode"] = "error";
      doc["sensor_available"] = true;
      doc["timestamp"] = millis();
      doc["customer_id"] = CUSTOMER_ID;
      doc["troubleshooting"] = "Sensor detected but readings invalid - check sensor condition and I2C communication";
      
      String jsonString;
      serializeJson(doc, jsonString);
      Serial.printf("ERROR: Sensor reading failed - Temp: %.2f°C, Humidity: %.2f%%\n", temperature, humidity);
      request->send(500, "application/json", jsonString);
      return;
    }
    
    // Valid sensor data - return success response
    doc["success"] = true;
    doc["temp"] = round(temperature * 10) / 10.0; // Round to 1 decimal
    doc["humid"] = round(humidity * 10) / 10.0;   // Round to 1 decimal
    doc["sensor"] = "SHT30";
    doc["mode"] = "live";
    doc["sensor_available"] = true;
    doc["timestamp"] = millis();
    doc["customer_id"] = CUSTOMER_ID;
    
    String jsonString;
    serializeJson(doc, jsonString);
    Serial.printf("SUCCESS: Live sensor data - Temp: %.1f°C, Humidity: %.1f%%RH\n", temperature, humidity);
    request->send(200, "application/json", jsonString);
  });

  // Health endpoint
  server.on("/health", HTTP_GET, [](AsyncWebServerRequest *request) {
    JsonDocument doc;
    JsonObject serverObj = doc["server"].to<JsonObject>();
    serverObj["status"] = "healthy";
    serverObj["uptime_ms"] = millis();
    serverObj["connected_clients"] = WiFi.softAPgetStationNum();
    
    String jsonString;
    serializeJson(doc, jsonString);
    request->send(200, "application/json", jsonString);
  });

  // Start server
  Serial.println("Starting HTTP server...");
  server.begin();
  Serial.println("Server started successfully!");
  Serial.println("Ready for client connections.");
}

void loop() {
  // Status reporting
  static unsigned long lastStatus = 0;
  if (millis() - lastStatus > 30000) {
    Serial.printf("[%s] Status: %d clients, %d bytes free\n", 
                  CUSTOMER_ID, WiFi.softAPgetStationNum(), ESP.getFreeHeap());
    lastStatus = millis();
  }
  
  delay(1000);
}