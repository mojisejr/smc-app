import fs from "fs/promises";
import path from "path";
import chalk from "chalk";
import { GenerateOptions } from "../types";
import { getESP32MacAddress } from "./esp32";
import { LicenseRegistry } from "./license-registry";
import {
  createLicenseData,
  createLicenseFile,
  encryptLicenseData,
  validateLicenseData,
} from "./encryption";

/**
 * License Generation Module
 *
 * ‡∏£‡∏ß‡∏ö‡∏£‡∏ß‡∏° ESP32 communication ‡πÅ‡∏•‡∏∞ encryption
 * ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏™‡∏£‡πâ‡∏≤‡∏á license file ‡πÅ‡∏ö‡∏ö‡∏Ñ‡∏£‡∏ö‡∏Ñ‡∏£‡∏±‡∏ô
 */

/**
 * ‡∏™‡∏£‡πâ‡∏≤‡∏á license file ‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå
 *
 * @param options - Generation options from CLI
 * @returns Path to generated license file
 */
export async function generateLicenseFile(
  options: GenerateOptions
): Promise<string> {
  try {
    console.log(chalk.blue("\nüöÄ Starting license generation process..."));
    console.log(chalk.gray("====================================="));

    // Step 1: ‡∏î‡∏∂‡∏á MAC address ‡∏à‡∏≤‡∏Å ESP32
    console.log(chalk.cyan("\nüì° Step 1: Connecting to ESP32..."));
    const esp32Response = await getESP32MacAddress(options.esp32Ip);

    if (esp32Response.status !== "success") {
      throw new Error("Failed to retrieve MAC address from ESP32");
    }

    const macAddress = esp32Response.mac;
    console.log(chalk.green(`‚úÖ MAC address retrieved: ${macAddress}`));

    // Step 2: ‡∏™‡∏£‡πâ‡∏≤‡∏á license data structure
    console.log(chalk.cyan("\nüìù Step 2: Creating license data..."));

    // Phase 9: ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ WiFi credentials ‡∏≠‡∏µ‡∏Å‡∏ï‡πà‡∏≠‡πÑ‡∏õ
    console.log(
      chalk.yellow(
        "   ‚ö†Ô∏è  Phase 9: WiFi credentials no longer required for license generation"
      )
    );

    const licenseData = createLicenseData(
      {
        org: options.org,
        customer: options.customer,
        app: options.app,
        expiry: options.expiry,
        type: options.type || "production",
      },
      macAddress
    );

    // Step 3: Validate license data
    console.log(chalk.cyan("\n‚úÖ Step 3: Validating license data..."));
    validateLicenseData(licenseData);

    // Step 4: ‡∏™‡∏£‡πâ‡∏≤‡∏á license file structure ‡πÅ‡∏•‡∏∞‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡∏´‡∏±‡∏™
    console.log(chalk.cyan("\nüîê Step 4: Creating encrypted license file..."));
    const licenseFile = createLicenseFile(licenseData);

    // Step 5: ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å license file
    console.log(chalk.cyan("\nüíæ Step 5: Saving license file..."));

    // ‡∏™‡∏£‡πâ‡∏≤‡∏á filename ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏£‡∏∞‡∏ö‡∏∏ extension
    let filename = options.output || "license.lic";
    if (!filename.endsWith(".lic")) {
      filename = filename.replace(/\.[^.]+$/, "") + ".lic"; // ‡πÅ‡∏ó‡∏ô‡∏ó‡∏µ‡πà extension ‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏û‡∏¥‡πà‡∏° .lic
    }

    // ‡∏™‡∏£‡πâ‡∏≤‡∏á absolute path
    const outputPath = path.resolve(process.cwd(), filename);

    // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÄ‡∏õ‡πá‡∏ô JSON format
    const licenseFileContent = JSON.stringify(licenseFile, null, 2);
    await fs.writeFile(outputPath, licenseFileContent, "utf8");

    console.log(chalk.green(`‚úÖ License file saved: ${outputPath}`));
    console.log(chalk.gray(`   File size: ${licenseFileContent.length} bytes`));

    // Step 6: Audit logging for internal/development licenses
    if (
      licenseData.license_type === "internal" ||
      licenseData.license_type === "development"
    ) {
      console.log(chalk.cyan("\nüîç Step 6: Audit Logging..."));
      const registry = new LicenseRegistry({ verbose: true });
      await registry.logInternalLicenseGeneration({
        organization: licenseData.organization,
        customer_id: licenseData.customerId,
        application_name: licenseData.applicationId,
        license_type: licenseData.license_type,
        file_path: outputPath,
        generated_by: process.env.USER || process.env.USERNAME || "CLI_USER",
        purpose:
          licenseData.license_type === "internal"
            ? "INTERNAL_DEPLOYMENT"
            : "DEVELOPMENT_TESTING",
      });
      console.log(
        chalk.green(
          `‚úÖ Audit log recorded for ${licenseData.license_type} license`
        )
      );
    }

    // Step 7: ‡πÅ‡∏™‡∏î‡∏á‡∏™‡∏£‡∏∏‡∏õ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå
    console.log(chalk.blue("\nüìä License Generation Summary:"));
    console.log(chalk.gray("====================================="));
    console.log(chalk.white(`Organization:     ${licenseData.organization}`));
    console.log(chalk.white(`Customer ID:      ${licenseData.customerId}`));
    console.log(chalk.white(`Application ID:   ${licenseData.applicationId}`));
    console.log(chalk.white(`MAC Address:      ${licenseData.macAddress}`));
    console.log(chalk.white(`Generated At:     ${licenseData.generatedAt}`));
    console.log(chalk.white(`Expires On:       ${licenseData.expiryDate}`));
    console.log(chalk.white(`Checksum:         ${licenseData.checksum}`));
    console.log(chalk.white(`Output File:      ${outputPath}`));
    console.log(chalk.white(`Encryption:       AES-256-CBC`));
    console.log(
      chalk.white(
        `License Type:     ${
          licenseData.license_type?.toUpperCase() || "PRODUCTION"
        }`
      )
    );

    // Special warnings for internal/development licenses
    if (licenseData.license_type === "internal") {
      console.log(chalk.red("\n‚ö†Ô∏è  INTERNAL LICENSE WARNING:"));
      console.log(chalk.red("   This license bypasses ESP32 validation"));
      console.log(chalk.red("   Only for SMC internal deployment"));
      console.log(chalk.red("   Audit trail has been recorded"));
    } else if (licenseData.license_type === "development") {
      console.log(chalk.yellow("\n‚ö†Ô∏è  DEVELOPMENT LICENSE WARNING:"));
      console.log(
        chalk.yellow("   This license is for development/testing only")
      );
      console.log(chalk.yellow("   Not suitable for production deployment"));
    }

    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏•‡∏∑‡∏≠
    const expiryDate = new Date(licenseData.expiryDate);
    const today = new Date();
    const daysUntilExpiry = Math.ceil(
      (expiryDate.getTime() - today.getTime()) / (1000 * 60 * 60 * 24)
    );
    console.log(chalk.white(`Days Until Expiry: ${daysUntilExpiry} days`));

    // Step 7: ‡πÅ‡∏™‡∏î‡∏á Self-Contained License Information
    console.log(chalk.blue("\nüéÜ Self-Contained License Information:"));
    console.log(chalk.gray("====================================="));
    console.log(
      chalk.white("This license uses Dynamic Shared Key technology:")
    );
    console.log(chalk.green(`‚Ä¢ No separate shared key management required`));
    console.log(chalk.green(`‚Ä¢ License is self-contained and secure`));
    console.log(chalk.green(`‚Ä¢ Unique encryption key per license`));

    console.log(chalk.white("\nüìù Deployment Instructions:"));
    console.log(
      chalk.cyan(`# Simply copy the license file to your application:`)
    );
    console.log(
      chalk.gray(`cp ${path.basename(outputPath)} /path/to/your/app/`)
    );
    console.log(chalk.cyan(`# No .env file setup required!`));

    console.log(chalk.yellow("\n‚ö†Ô∏è  Security Notes:"));
    console.log(chalk.gray("‚Ä¢ Each license has a unique encryption key"));
    console.log(chalk.gray("‚Ä¢ Key is derived from license data automatically"));
    console.log(
      chalk.gray("‚Ä¢ Only license.lic file is required for activation")
    );

    console.log(chalk.green("\nüéâ License generation completed successfully!"));

    return outputPath;
  } catch (error: any) {
    console.log(chalk.red("\n‚ùå License generation failed:"));
    console.log(chalk.red(`Error: ${error.message}`));

    // Troubleshooting suggestions
    console.log(chalk.yellow("\nüîß Troubleshooting:"));
    console.log(
      chalk.gray("1. Ensure ESP32 is accessible and /mac endpoint is working")
    );
    console.log(
      chalk.gray(
        "2. Check that expiry date is in YYYY-MM-DD format and in the future"
      )
    );
    console.log(chalk.gray("3. Verify write permissions for output directory"));
    console.log(
      chalk.gray("4. Make sure all required parameters are provided")
    );

    throw error;
  }
}

/**
 * ‡∏™‡∏£‡πâ‡∏≤‡∏á sample license file ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ó‡∏î‡∏™‡∏≠‡∏ö (‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ ESP32 ‡∏à‡∏£‡∏¥‡∏á)
 *
 * @param options - Generation options
 * @param mockMacAddress - Mock MAC address ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ó‡∏î‡∏™‡∏≠‡∏ö
 * @returns Path to generated license file
 */
export async function generateSampleLicenseFile(
  options: GenerateOptions,
  mockMacAddress: string = "AA:BB:CC:DD:EE:FF"
): Promise<string> {
  try {
    console.log(
      chalk.blue("\nüß™ Generating sample license file (without ESP32)...")
    );
    console.log(
      chalk.yellow("‚ö†Ô∏è  This is a test license with mock MAC address")
    );
    console.log(chalk.gray("====================================="));

    // ‡∏™‡∏£‡πâ‡∏≤‡∏á license data ‡∏î‡πâ‡∏ß‡∏¢ mock MAC
    console.log(chalk.cyan("\nüìù Creating license data with mock MAC..."));

    // Phase 9: ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ WiFi credentials ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö test license
    console.log(
      chalk.yellow(
        "   ‚ö†Ô∏è  Phase 9: Test license generation without WiFi credentials"
      )
    );

    const licenseData = createLicenseData(
      {
        org: options.org,
        customer: options.customer,
        app: `${options.app}_TEST`, // ‡πÄ‡∏û‡∏¥‡πà‡∏° _TEST ‡∏Å‡πà‡∏≠‡∏ô‡∏™‡∏£‡πâ‡∏≤‡∏á checksum
        expiry: options.expiry,
        type: options.type || "production",
      },
      mockMacAddress
    );

    // Validate ‡πÅ‡∏•‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå
    validateLicenseData(licenseData);
    const licenseFile = createLicenseFile(licenseData);

    // ‡∏™‡∏£‡πâ‡∏≤‡∏á test filename
    let filename = options.output || "license.lic";
    if (!filename.endsWith(".lic")) {
      filename = filename.replace(/\.[^.]+$/, "") + ".lic";
    }

    // ‡πÄ‡∏û‡∏¥‡πà‡∏° _test suffix
    const testFilename = filename.replace(".lic", "_test.lic");
    const outputPath = path.resolve(process.cwd(), testFilename);

    // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÑ‡∏ü‡∏•‡πå
    const licenseFileContent = JSON.stringify(licenseFile, null, 2);
    await fs.writeFile(outputPath, licenseFileContent, "utf8");

    console.log(chalk.green(`‚úÖ Sample license file saved: ${outputPath}`));
    console.log(
      chalk.yellow(`‚ö†Ô∏è  This license uses mock MAC address: ${mockMacAddress}`)
    );

    // Audit logging for internal/development test licenses
    if (
      licenseData.license_type === "internal" ||
      licenseData.license_type === "development"
    ) {
      console.log(chalk.cyan("\nüîç Audit Logging for Test License..."));
      const registry = new LicenseRegistry({ verbose: true });
      await registry.logInternalLicenseGeneration({
        organization: licenseData.organization,
        customer_id: licenseData.customerId,
        application_name: licenseData.applicationId,
        license_type: licenseData.license_type,
        file_path: outputPath,
        generated_by: process.env.USER || process.env.USERNAME || "CLI_USER",
        purpose: `${licenseData.license_type.toUpperCase()}_TESTING`,
      });
      console.log(
        chalk.green(
          `‚úÖ Audit log recorded for ${licenseData.license_type} test license`
        )
      );
    }

    // ‡πÅ‡∏™‡∏î‡∏á Self-Contained License Information
    console.log(chalk.blue("\nüéÜ Self-Contained Test License Information:"));
    console.log(chalk.gray("====================================="));
    console.log(
      chalk.white("This test license uses Dynamic Shared Key technology:")
    );
    console.log(chalk.green(`‚Ä¢ No separate shared key management required`));
    console.log(chalk.green(`‚Ä¢ License is self-contained and secure`));
    console.log(chalk.green(`‚Ä¢ Unique encryption key per license`));

    // Special warnings for internal/development test licenses
    if (licenseData.license_type === "internal") {
      console.log(chalk.red("\n‚ö†Ô∏è  INTERNAL TEST LICENSE WARNING:"));
      console.log(chalk.red("   This test license bypasses ESP32 validation"));
      console.log(chalk.red("   Only for SMC internal testing"));
      console.log(chalk.red("   Uses mock MAC address - not for production"));
    } else if (licenseData.license_type === "development") {
      console.log(chalk.yellow("\n‚ö†Ô∏è  DEVELOPMENT TEST LICENSE WARNING:"));
      console.log(
        chalk.yellow("   This test license is for development/testing only")
      );
      console.log(
        chalk.yellow("   Uses mock MAC address - not suitable for production")
      );
    }

    console.log(chalk.white("\nüìù Test Deployment Instructions:"));
    console.log(chalk.cyan(`# Simply copy the test license file:`));
    console.log(
      chalk.gray(
        `cp ${path.basename(outputPath)} /path/to/your/app/license.lic`
      )
    );
    console.log(chalk.cyan(`# No .env file setup required!`));

    console.log(chalk.yellow("\n‚ö†Ô∏è  Test Mode Reminder:"));
    console.log(chalk.gray("‚Ä¢ This uses mock MAC address for testing"));
    console.log(chalk.gray("‚Ä¢ Use without --test-mode for production"));
    console.log(
      chalk.gray("‚Ä¢ Self-contained license system - no shared key needed")
    );

    return outputPath;
  } catch (error: any) {
    console.log(chalk.red("\n‚ùå Sample license generation failed:"));
    console.log(chalk.red(`Error: ${error.message}`));
    throw error;
  }
}

/**
 * ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• license file ‡πÉ‡∏ô‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏ó‡∏µ‡πà‡∏≠‡πà‡∏≤‡∏ô‡∏á‡πà‡∏≤‡∏¢
 *
 * @param filePath - Path to license file
 */
export async function displayLicenseInfo(filePath: string): Promise<void> {
  try {
    console.log(
      chalk.blue(`\nüìÑ License File Information: ${path.basename(filePath)}`)
    );
    console.log(chalk.gray("====================================="));

    // ‡∏≠‡πà‡∏≤‡∏ô‡πÑ‡∏ü‡∏•‡πå
    const fileContent = await fs.readFile(filePath, "utf8");
    const licenseFile = JSON.parse(fileContent);

    // ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• file structure
    console.log(chalk.cyan("üìã File Structure:"));
    console.log(chalk.white(`   Format Version: ${licenseFile.version}`));
    console.log(chalk.white(`   Algorithm: ${licenseFile.algorithm}`));
    console.log(chalk.white(`   Created At: ${licenseFile.created_at}`));
    console.log(chalk.white(`   File Size: ${fileContent.length} bytes`));

    // ‡∏ñ‡∏≠‡∏î‡∏£‡∏´‡∏±‡∏™‡πÅ‡∏•‡∏∞‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• license
    console.log(chalk.cyan("\nüîì License Data:"));
    // TODO: Implement decryption display ‡πÉ‡∏ô Phase 4
    console.log(
      chalk.yellow(
        "   (License data decryption will be implemented in Phase 4)"
      )
    );
  } catch (error: any) {
    console.log(chalk.red("\n‚ùå Failed to display license info:"));
    console.log(chalk.red(`Error: ${error.message}`));
    throw error;
  }
}

/**
 * ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÑ‡∏ü‡∏•‡πå license ‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡∏∞‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏≠‡πà‡∏≤‡∏ô‡πÑ‡∏î‡πâ
 *
 * @param filePath - Path to license file
 * @returns true if file exists and readable
 */
export async function checkLicenseFileExists(
  filePath: string
): Promise<boolean> {
  try {
    await fs.access(filePath, fs.constants.F_OK | fs.constants.R_OK);
    return true;
  } catch {
    return false;
  }
}
