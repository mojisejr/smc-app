import crypto from 'crypto';
import chalk from 'chalk';
import { LicenseData, LicenseFile, EncryptionConfig, WiFiPasswordValidation, KDFContext } from '../types';

/**
 * Encryption Module for SMC License System
 * 
 * ‡πÉ‡∏ä‡πâ AES-256-CBC ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡∏´‡∏±‡∏™ license data
 * ‡πÉ‡∏ä‡πâ HKDF (RFC 5869) ‡πÅ‡∏ó‡∏ô Dynamic Key ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î
 * ‡πÑ‡∏°‡πà‡∏°‡∏µ sensitive data ‡πÉ‡∏ô license file ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô MAC address exposure
 */

// Encryption configuration
const ENCRYPTION_CONFIG = {
  algorithm: 'aes-256-cbc',
  iv_length: 16 // 16 bytes IV for AES
};

// HKDF configuration (RFC 5869)
const HKDF_CONFIG = {
  hash: 'sha256',
  key_length: 32, // 32 bytes for AES-256
  salt_length: 32, // 32 bytes random salt
  info_prefix: 'SMC_LICENSE_KDF_v1.0' // Context info prefix
};

/**
 * Generate random salt for HKDF
 * 
 * @returns Random salt buffer (32 bytes)
 */
function generateSalt(): Buffer {
  return crypto.randomBytes(HKDF_CONFIG.salt_length);
}

/**
 * Create deterministic KDF context from stable license data
 * ‡πÉ‡∏ä‡πâ stable salt ‡∏à‡∏≤‡∏Å non-sensitive data ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ regenerate ‡πÑ‡∏î‡πâ
 * 
 * @param licenseData - License data object
 * @returns KDF context (deterministic but secure)
 */
export function createKDFContext(licenseData: LicenseData): KDFContext {
  console.log(chalk.blue('üîë Creating deterministic KDF context...'));
  
  // ‡∏™‡∏£‡πâ‡∏≤‡∏á deterministic salt ‡∏à‡∏≤‡∏Å non-sensitive stable data
  const saltInput = `${licenseData.applicationId}|${licenseData.customerId}|${licenseData.expiryDate}`;
  const salt = crypto.createHash('sha256').update(saltInput).digest();
  
  // ‡∏™‡∏£‡πâ‡∏≤‡∏á info context ‡∏à‡∏≤‡∏Å non-sensitive data ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô
  const contextParts = [
    HKDF_CONFIG.info_prefix,
    licenseData.applicationId,
    licenseData.customerId,
    licenseData.expiryDate,
    licenseData.version || '1.0.0'
  ];
  
  const info = contextParts.join('|');
  
  const kdfContext: KDFContext = {
    salt: salt.toString('base64'),
    info: info,
    algorithm: 'hkdf-sha256'
  };
  
  console.log(chalk.green('   ‚úÖ Deterministic KDF context created'));
  console.log(chalk.gray(`   Salt (deterministic): ${salt.toString('base64').substring(0, 16)}...`));
  console.log(chalk.gray(`   Info: ${info.substring(0, 50)}...`));
  console.log(chalk.blue('   üîÑ Same input data ‚Üí Same KDF context ‚Üí Same license'));
  
  return kdfContext;
}

/**
 * Generate HKDF key from license data ‡πÅ‡∏•‡∏∞ KDF context
 * ‡πÉ‡∏ä‡πâ HKDF (RFC 5869) ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö secure key derivation
 * 
 * @param licenseData - Complete license data (‡∏£‡∏ß‡∏° sensitive data)
 * @param kdfContext - KDF context ‡∏à‡∏≤‡∏Å license file
 * @returns 32-byte encryption key
 */
export function generateHKDFKey(licenseData: LicenseData, kdfContext: KDFContext): Buffer {
  console.log(chalk.blue('üîê Generating HKDF key...'));
  
  try {
    // ‡∏™‡∏£‡πâ‡∏≤‡∏á Input Key Material (IKM) ‡∏à‡∏≤‡∏Å sensitive license data
    const ikm_parts = [
      licenseData.applicationId,
      licenseData.customerId,
      licenseData.wifiSsid,
      licenseData.macAddress, // Sensitive data - ‡πÑ‡∏°‡πà‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô context
      licenseData.expiryDate
    ];
    
    const ikm = Buffer.from(ikm_parts.join('_'), 'utf8');
    
    // ‡πÅ‡∏õ‡∏•‡∏á salt ‡∏à‡∏≤‡∏Å base64
    const salt = Buffer.from(kdfContext.salt, 'base64');
    
    // ‡πÅ‡∏õ‡∏•‡∏á info ‡∏à‡∏≤‡∏Å string
    const info = Buffer.from(kdfContext.info, 'utf8');
    
    console.log(chalk.gray(`   IKM size: ${ikm.length} bytes`));
    console.log(chalk.gray(`   Salt size: ${salt.length} bytes`));
    console.log(chalk.gray(`   Info size: ${info.length} bytes`));
    
    // HKDF-Extract: PRK = HMAC-Hash(salt, IKM)
    const prk = crypto.createHmac(HKDF_CONFIG.hash, salt).update(ikm).digest();
    
    // HKDF-Expand: OKM = HMAC-Hash(PRK, info + 0x01)
    const expandInfo = Buffer.concat([info, Buffer.from([0x01])]);
    const okm = crypto.createHmac(HKDF_CONFIG.hash, prk).update(expandInfo).digest();
    
    // ‡∏ï‡∏±‡∏î key ‡πÉ‡∏´‡πâ‡πÑ‡∏î‡πâ‡∏Ç‡∏ô‡∏≤‡∏î‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£ (32 bytes ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö AES-256)
    const derivedKey = okm.slice(0, HKDF_CONFIG.key_length);
    
    console.log(chalk.green('   ‚úÖ HKDF key generated'));
    console.log(chalk.gray(`   Key size: ${derivedKey.length} bytes`));
    console.log(chalk.gray(`   Key preview: ${derivedKey.toString('hex').substring(0, 8)}...`));
    
    return derivedKey;
    
  } catch (error: any) {
    console.log(chalk.red(`   ‚ùå HKDF key generation failed: ${error.message}`));
    throw new Error(`HKDF key generation failed: ${error.message}`);
  }
}


/**
 * ‡∏™‡∏£‡πâ‡∏≤‡∏á IV (Initialization Vector) ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö AES encryption
 */
function generateIV(): Buffer {
  return crypto.randomBytes(ENCRYPTION_CONFIG.iv_length);
}

/**
 * ‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡∏´‡∏±‡∏™‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• license ‡∏î‡πâ‡∏ß‡∏¢ AES-256-CBC + HKDF
 * 
 * @param data - License data object
 * @param kdfContext - KDF context ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö key derivation
 * @returns Encrypted string (Base64)
 */
export function encryptLicenseData(data: LicenseData, kdfContext: KDFContext): string {
  try {
    console.log(chalk.blue('üîê Encrypting license data with HKDF...'));
    
    // ‡∏™‡∏£‡πâ‡∏≤‡∏á HKDF key ‡∏à‡∏≤‡∏Å license data ‡πÅ‡∏•‡∏∞ KDF context
    const derivedKey = generateHKDFKey(data, kdfContext);
    
    // Convert license data ‡πÄ‡∏õ‡πá‡∏ô JSON string (compact format ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö performance)
    const jsonString = JSON.stringify(data, null, 0);
    console.log(chalk.gray(`   Data size: ${jsonString.length} bytes`));
    
    // Generate random IV
    const iv = generateIV();
    
    // ‡∏™‡∏£‡πâ‡∏≤‡∏á cipher ‡∏î‡πâ‡∏ß‡∏¢ createCipheriv ‡∏î‡πâ‡∏ß‡∏¢ HKDF key
    const cipher = crypto.createCipheriv(ENCRYPTION_CONFIG.algorithm, derivedKey, iv);
    
    // ‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡∏´‡∏±‡∏™‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
    let encrypted = cipher.update(jsonString, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    
    // ‡∏£‡∏ß‡∏° IV ‡∏Å‡∏±‡∏ö encrypted data (IV:ENCRYPTED_DATA)
    const result = iv.toString('hex') + ':' + encrypted;
    
    console.log(chalk.green(`   ‚úÖ HKDF encryption successful`));
    console.log(chalk.gray(`   Encrypted size: ${result.length} characters`));
    
    return Buffer.from(result).toString('base64'); // Convert ‡πÄ‡∏õ‡πá‡∏ô Base64 ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∞‡∏î‡∏ß‡∏Å‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡πÄ‡∏Å‡πá‡∏ö
    
  } catch (error: any) {
    console.log(chalk.red(`   ‚ùå HKDF encryption failed: ${error.message}`));
    throw new Error(`License HKDF encryption failed: ${error.message}`);
  }
}

/**
 * ‡∏ñ‡∏≠‡∏î‡∏£‡∏´‡∏±‡∏™‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• license ‡∏î‡πâ‡∏ß‡∏¢ AES-256-CBC + HKDF
 * 
 * @param encryptedData - Encrypted string (Base64)
 * @param kdfContext - KDF context ‡∏à‡∏≤‡∏Å license file
 * @param keyData - Key data for HKDF (‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏£‡∏π‡πâ sensitive data)
 * @returns License data object
 */
export function decryptLicenseData(
  encryptedData: string,
  kdfContext: KDFContext,
  keyData: {
    applicationId: string;
    customerId: string;
    wifiSsid: string;
    macAddress: string;
    expiryDate: string;
  }
): LicenseData {
  try {
    console.log(chalk.blue('üîì Decrypting license data with HKDF...'));
    
    // ‡∏™‡∏£‡πâ‡∏≤‡∏á temporary license data object ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö HKDF key generation
    const tempLicenseData: LicenseData = {
      applicationId: keyData.applicationId,
      customerId: keyData.customerId,
      wifiSsid: keyData.wifiSsid,
      macAddress: keyData.macAddress,
      expiryDate: keyData.expiryDate,
      organization: '', // ‡∏à‡∏∞‡πÑ‡∏î‡πâ‡∏à‡∏≤‡∏Å decrypted data
      generatedAt: '',
      wifiPassword: '',
      version: '1.0.0',
      checksum: ''
    };
    
    // ‡∏™‡∏£‡πâ‡∏≤‡∏á HKDF key ‡∏à‡∏≤‡∏Å key data ‡πÅ‡∏•‡∏∞ KDF context
    const derivedKey = generateHKDFKey(tempLicenseData, kdfContext);
    
    console.log(chalk.gray(`   Using HKDF key for decryption`));
    
    // Decode ‡∏à‡∏≤‡∏Å Base64
    const hexData = Buffer.from(encryptedData, 'base64').toString('utf8');
    
    // ‡πÅ‡∏¢‡∏Å IV ‡∏Å‡∏±‡∏ö encrypted data
    const parts = hexData.split(':');
    if (parts.length !== 2) {
      throw new Error('Invalid encrypted data format');
    }
    
    const iv = Buffer.from(parts[0], 'hex');
    const encrypted = parts[1];
    
    console.log(chalk.gray(`   IV length: ${iv.length} bytes`));
    console.log(chalk.gray(`   Data length: ${encrypted.length} characters`));
    
    // ‡∏™‡∏£‡πâ‡∏≤‡∏á decipher ‡∏î‡πâ‡∏ß‡∏¢ createDecipheriv ‡∏î‡πâ‡∏ß‡∏¢ HKDF key
    const decipher = crypto.createDecipheriv(ENCRYPTION_CONFIG.algorithm, derivedKey, iv);
    
    // ‡∏ñ‡∏≠‡∏î‡∏£‡∏´‡∏±‡∏™‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
    let decrypted = decipher.update(encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    
    // Parse JSON
    const decryptedLicenseData = JSON.parse(decrypted);
    
    console.log(chalk.green(`   ‚úÖ HKDF decryption successful`));
    console.log(chalk.gray(`   Organization: ${decryptedLicenseData.organization}`));
    
    return decryptedLicenseData as LicenseData;
    
  } catch (error: any) {
    console.log(chalk.red(`   ‚ùå HKDF decryption failed: ${error.message}`));
    throw new Error(`License HKDF decryption failed: ${error.message}`);
  }
}

/**
 * ‡∏™‡∏£‡πâ‡∏≤‡∏á license data object ‡∏à‡∏≤‡∏Å input parameters
 * 
 * @param options - License generation options
 * @param macAddress - MAC address from ESP32
 * @param wifiCredentials - WiFi SSID and password for ESP32 connection
 * @returns LicenseData object
 */
export function createLicenseData(
  options: {
    org: string;
    customer: string;
    app: string;
    expiry: string;
  },
  macAddress: string,
  wifiCredentials: {
    ssid: string;
    password: string;
  }
): LicenseData {
  
  console.log(chalk.blue('üìù Creating license data structure...'));
  
  // Validate expiry date format (YYYY-MM-DD)
  const expiryRegex = /^\d{4}-\d{2}-\d{2}$/;
  if (!expiryRegex.test(options.expiry)) {
    throw new Error('Invalid expiry date format. Use YYYY-MM-DD');
  }
  
  // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏ß‡∏±‡∏ô‡∏´‡∏°‡∏î‡∏≠‡∏≤‡∏¢‡∏∏‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡∏≠‡∏î‡∏µ‡∏ï
  const expiryDate = new Date(options.expiry);
  const today = new Date();
  today.setHours(0, 0, 0, 0); // Reset time to beginning of day
  
  if (expiryDate < today) {
    throw new Error('Expiry date cannot be in the past');
  }
  
  // ‡∏™‡∏£‡πâ‡∏≤‡∏á license data
  const licenseData: LicenseData = {
    organization: options.org.trim(),
    customerId: options.customer.trim(),
    applicationId: options.app.trim(),
    generatedAt: new Date().toISOString(),
    expiryDate: options.expiry,
    macAddress: macAddress.toUpperCase(), // Normalize MAC address ‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÉ‡∏´‡∏ç‡πà
    wifiSsid: wifiCredentials.ssid.trim(),
    wifiPassword: wifiCredentials.password,
    version: '1.0.0',
    checksum: '' // ‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å‡∏ô‡∏µ‡πâ
  };
  
  // ‡∏™‡∏£‡πâ‡∏≤‡∏á checksum ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö verification (‡∏£‡∏ß‡∏° WiFi data)
  const checksumData = `${licenseData.organization}${licenseData.customerId}${licenseData.applicationId}${licenseData.expiryDate}${licenseData.macAddress}${licenseData.wifiSsid}`;
  licenseData.checksum = crypto.createHash('sha256').update(checksumData).digest('hex').slice(0, 16);
  
  console.log(chalk.green('   ‚úÖ License data created'));
  console.log(chalk.gray(`   Organization: ${licenseData.organization}`));
  console.log(chalk.gray(`   Customer ID: ${licenseData.customerId}`));
  console.log(chalk.gray(`   Application: ${licenseData.applicationId}`));
  console.log(chalk.gray(`   Expiry: ${licenseData.expiryDate}`));
  console.log(chalk.gray(`   MAC Address: ${licenseData.macAddress}`));
  console.log(chalk.gray(`   WiFi SSID: ${licenseData.wifiSsid}`));
  console.log(chalk.gray(`   WiFi Password: ${'*'.repeat(licenseData.wifiPassword.length)}`)); // ‡∏ã‡πà‡∏≠‡∏ô password
  console.log(chalk.gray(`   Checksum: ${licenseData.checksum}`));
  
  return licenseData;
}

/**
 * ‡∏™‡∏£‡πâ‡∏≤‡∏á license file structure ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏•‡∏á‡πÑ‡∏ü‡∏•‡πå (HKDF Version)
 * 
 * @param licenseData - License data object
 * @returns LicenseFile object
 */
export function createLicenseFile(licenseData: LicenseData): LicenseFile {
  console.log(chalk.blue('üìÑ Creating HKDF license file structure...'));
  
  // ‡∏™‡∏£‡πâ‡∏≤‡∏á KDF context (‡πÑ‡∏°‡πà‡∏£‡∏ß‡∏° sensitive data)
  const kdfContext = createKDFContext(licenseData);
  
  // ‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡∏´‡∏±‡∏™ license data ‡∏î‡πâ‡∏ß‡∏¢ HKDF
  const encryptedData = encryptLicenseData(licenseData, kdfContext);
  
  // ‡∏™‡∏£‡πâ‡∏≤‡∏á license file structure ‡∏û‡∏£‡πâ‡∏≠‡∏° KDF context (‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢)
  const licenseFile: LicenseFile = {
    version: '2.0.0', // ‡πÄ‡∏û‡∏¥‡πà‡∏° version ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏£‡∏∞‡∏ö‡∏∏ HKDF format
    encrypted_data: encryptedData,
    algorithm: ENCRYPTION_CONFIG.algorithm,
    created_at: new Date().toISOString(),
    
    // KDF context ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö HKDF key generation (‡πÑ‡∏°‡πà‡∏°‡∏µ sensitive data)
    kdf_context: kdfContext
  };
  
  console.log(chalk.green('   ‚úÖ HKDF license file structure created'));
  console.log(chalk.gray(`   Format version: ${licenseFile.version} (HKDF)`));
  console.log(chalk.gray(`   Algorithm: ${licenseFile.algorithm}`));
  console.log(chalk.gray(`   Created at: ${licenseFile.created_at}`));
  console.log(chalk.green('   üîí No sensitive data exposed in license file'));
  
  return licenseFile;
}

/**
 * ‡∏≠‡πà‡∏≤‡∏ô‡πÅ‡∏•‡∏∞ parse license file ‡∏î‡πâ‡∏ß‡∏¢ HKDF v2.0
 * 
 * @param licenseFileContent - License file content (JSON string)
 * @param sensitiveData - Sensitive data for key generation (MAC address, WiFi SSID)
 * @returns LicenseData object
 */
export function parseLicenseFile(
  licenseFileContent: string,
  sensitiveData: {
    macAddress: string;
    wifiSsid: string;
  }
): LicenseData {
  try {
    console.log(chalk.blue('üìñ Parsing HKDF license file...'));
    
    // Parse JSON
    const licenseFile = JSON.parse(licenseFileContent) as LicenseFile;
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö HKDF version
    if (licenseFile.version === '2.0.0' && licenseFile.kdf_context) {
      console.log(chalk.green('   ‚úÖ HKDF format detected'));
      
      // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö algorithm
      if (licenseFile.algorithm !== ENCRYPTION_CONFIG.algorithm) {
        throw new Error(`Unsupported encryption algorithm: ${licenseFile.algorithm}`);
      }
      
      console.log(chalk.gray(`   File version: ${licenseFile.version} (HKDF)`));
      console.log(chalk.gray(`   Algorithm: ${licenseFile.algorithm}`));
      console.log(chalk.gray(`   Created: ${licenseFile.created_at}`));
      
      // Parse KDF context ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÑ‡∏î‡πâ non-sensitive data
      const kdfInfo = licenseFile.kdf_context.info;
      const infoParts = kdfInfo.split('|');
      
      if (infoParts.length < 5) {
        throw new Error('Invalid KDF context info format');
      }
      
      // Extract non-sensitive data ‡∏à‡∏≤‡∏Å KDF context
      const applicationId = infoParts[1];
      const customerId = infoParts[2];
      const expiryDate = infoParts[3];
      
      console.log(chalk.gray(`   Application ID: ${applicationId}`));
      console.log(chalk.gray(`   Customer ID: ${customerId}`));
      console.log(chalk.gray(`   Expiry: ${expiryDate}`));
      
      // ‡∏™‡∏£‡πâ‡∏≤‡∏á key data ‡∏£‡∏ß‡∏° sensitive ‡πÅ‡∏•‡∏∞ non-sensitive data
      const keyData = {
        applicationId,
        customerId,
        wifiSsid: sensitiveData.wifiSsid,
        macAddress: sensitiveData.macAddress,
        expiryDate
      };
      
      // ‡∏ñ‡∏≠‡∏î‡∏£‡∏´‡∏±‡∏™ license data
      const licenseData = decryptLicenseData(
        licenseFile.encrypted_data,
        licenseFile.kdf_context,
        keyData
      );
      
      console.log(chalk.green('   ‚úÖ HKDF license file parsed successfully'));
      
      return licenseData;
    } else {
      throw new Error('Not a valid HKDF license file format (expected version 2.0.0 with kdf_context)');
    }
    
  } catch (error: any) {
    console.log(chalk.red(`   ‚ùå HKDF license file parsing failed: ${error.message}`));
    throw new Error(`Invalid HKDF license file: ${error.message}`);
  }
}


/**
 * ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏Ç‡∏≠‡∏á license data
 * 
 * @param licenseData - License data to validate
 * @returns true if valid, throws error if invalid
 */
export function validateLicenseData(licenseData: LicenseData): boolean {
  console.log(chalk.blue('‚úÖ Validating license data...'));
  
  // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö required fields (‡∏£‡∏ß‡∏° WiFi credentials)
  const requiredFields = ['organization', 'customerId', 'applicationId', 'expiryDate', 'macAddress', 'wifiSsid', 'wifiPassword'];
  for (const field of requiredFields) {
    if (!licenseData[field as keyof LicenseData]) {
      throw new Error(`Missing required field: ${field}`);
    }
  }
  
  // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö expiry date
  const expiryDate = new Date(licenseData.expiryDate);
  const today = new Date();
  
  if (expiryDate < today) {
    throw new Error('License has expired');
  }
  
  // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö checksum ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ (‡∏£‡∏ß‡∏° WiFi SSID)
  if (licenseData.checksum) {
    const checksumData = `${licenseData.organization}${licenseData.customerId}${licenseData.applicationId}${licenseData.expiryDate}${licenseData.macAddress}${licenseData.wifiSsid}`;
    const expectedChecksum = crypto.createHash('sha256').update(checksumData).digest('hex').slice(0, 16);
    
    if (licenseData.checksum !== expectedChecksum) {
      throw new Error('License data integrity check failed');
    }
  }
  
  console.log(chalk.green('   ‚úÖ License data validation passed'));
  console.log(chalk.gray(`   Valid until: ${licenseData.expiryDate}`));
  
  return true;
}

/**
 * ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö WiFi password strength
 * 
 * @param password - WiFi password to validate
 * @param bypassCheck - Skip validation for development
 * @returns WiFiPasswordValidation result
 */
/**
 * ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• basic ‡∏Ç‡∏≠‡∏á license file ‡πÇ‡∏î‡∏¢‡πÑ‡∏°‡πà decrypt
 * ‡πÉ‡∏ä‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö validate ‡πÅ‡∏•‡∏∞ info commands ‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏°‡∏µ sensitive data
 */
export function getLicenseFileBasicInfo(licenseFileContent: string): {
  isValid: boolean;
  errors: string[];
  fileInfo?: {
    version: string;
    algorithm: string;
    created_at: string;
    encrypted_data_length: number;
    has_kdf_context: boolean;
    kdf_algorithm?: string;
    file_size: number;
  };
} {
  const result: any = {
    isValid: false,
    errors: []
  };

  try {
    // Parse JSON
    const licenseFile = JSON.parse(licenseFileContent);
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö required fields ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö HKDF v2.0
    const requiredFields = ['version', 'encrypted_data', 'algorithm', 'created_at', 'kdf_context'];
    const missingFields = requiredFields.filter(field => !(field in licenseFile));
    
    if (missingFields.length > 0) {
      result.errors.push(`Missing required fields: ${missingFields.join(', ')}`);
      return result;
    }
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö KDF context structure
    if (!licenseFile.kdf_context || typeof licenseFile.kdf_context !== 'object') {
      result.errors.push('Invalid or missing kdf_context');
      return result;
    }
    
    const kdfRequiredFields = ['salt', 'info', 'algorithm'];
    const kdfMissingFields = kdfRequiredFields.filter(field => !(field in licenseFile.kdf_context));
    
    if (kdfMissingFields.length > 0) {
      result.errors.push(`Missing KDF context fields: ${kdfMissingFields.join(', ')}`);
      return result;
    }
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö version compatibility
    if (!licenseFile.version.startsWith('2.0')) {
      result.errors.push(`Unsupported license version: ${licenseFile.version}. HKDF system requires version 2.0.x`);
      return result;
    }
    
    // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• basic info
    result.isValid = true;
    result.fileInfo = {
      version: licenseFile.version,
      algorithm: licenseFile.algorithm,
      created_at: licenseFile.created_at,
      encrypted_data_length: licenseFile.encrypted_data.length,
      has_kdf_context: true,
      kdf_algorithm: licenseFile.kdf_context.algorithm,
      file_size: licenseFileContent.length
    };
    
    return result;
    
  } catch (error: any) {
    result.errors.push(`JSON parsing error: ${error.message}`);
    return result;
  }
}

export function validateWiFiPassword(password: string, bypassCheck: boolean = false): WiFiPasswordValidation {
  const result: WiFiPasswordValidation = {
    isValid: true,
    strength: 'medium',
    errors: [],
    warnings: []
  };

  // ‡∏ñ‡πâ‡∏≤ bypass ‡πÉ‡∏´‡πâ‡∏ú‡πà‡∏≤‡∏ô‡∏ó‡∏∏‡∏Å‡∏≠‡∏¢‡πà‡∏≤‡∏á ‡πÅ‡∏ï‡πà‡∏¢‡∏±‡∏á‡πÅ‡∏™‡∏î‡∏á warning
  if (bypassCheck) {
    console.log(chalk.yellow('‚ö†Ô∏è  Password validation bypassed for development'));
    result.warnings.push('Password validation bypassed - use strong passwords in production');
    return result;
  }

  // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏≤‡∏ß
  if (password.length < 8) {
    result.errors.push('Password must be at least 8 characters long');
    result.isValid = false;
  }

  if (password.length < 12) {
    result.warnings.push('Consider using passwords longer than 12 characters');
  }

  // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö complexity
  const hasLowerCase = /[a-z]/.test(password);
  const hasUpperCase = /[A-Z]/.test(password);
  const hasNumbers = /\d/.test(password);
  const hasSpecialChars = /[!@#$%^&*(),.?":{}|<>]/.test(password);

  const complexityScore = [hasLowerCase, hasUpperCase, hasNumbers, hasSpecialChars].filter(Boolean).length;

  if (complexityScore < 2) {
    result.errors.push('Password must contain at least 2 types: lowercase, uppercase, numbers, special characters');
    result.isValid = false;
  }

  // ‡∏Å‡∏≥‡∏´‡∏ô‡∏î strength
  if (complexityScore >= 4 && password.length >= 12) {
    result.strength = 'strong';
  } else if (complexityScore >= 3 && password.length >= 8) {
    result.strength = 'medium';
  } else {
    result.strength = 'weak';
  }

  // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö common weak passwords
  const weakPasswords = ['password', '123456', 'wifi123', 'admin123', 'smc123'];
  if (weakPasswords.some(weak => password.toLowerCase().includes(weak))) {
    result.warnings.push('Avoid using common password patterns');
    result.strength = 'weak';
  }

  return result;
}